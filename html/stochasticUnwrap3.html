
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>stochasticUnwrap3</title><meta name="generator" content="MATLAB 9.1"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2016-09-29"><meta name="DC.source" content="stochasticUnwrap3.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#2">The data</a></li><li><a href="#3">Real data</a></li><li><a href="#4">The problem</a></li><li><a href="#5">Step 1: Single, simple unwraps</a></li><li><a href="#6">Experimental noise</a></li><li><a href="#7">Add noise (before unwrapping) and unwrap again</a></li><li><a href="#8">Select best path</a></li></ul></div><pre class="codeinput"><span class="comment">% Examples using unwrap3</span>
<span class="comment">% Allows different values for correcting up and down jumps</span>
close <span class="string">all</span>
</pre><h2 id="2">The data</h2><p>What the data looks like</p><pre class="codeinput"><span class="comment">% This is what we're assuming clean data roughly looks like</span>
<span class="comment">% (oversimiplified a bit)</span>
<span class="comment">% x is distance</span>
<span class="comment">% y is phase in degrees</span>

x = 1:18;
y = linspace(0, -480, numel(x));

figure
subplot(4,1,1)
plot(x,y)
xlabel(<span class="string">'Distance'</span>)
ylabel(<span class="string">'Phase, deg.'</span>)
axis([0, 20, -600, 200])
title(<span class="string">'Clean data'</span>)

<span class="comment">% Raw data can only be recorded between 0-360 degrees, so clean data in</span>
<span class="comment">% it's raw form would look like this.</span>
y(y&lt;-360) = y(y&lt;-360)+360;

subplot(4,1,2)
plot(x,y)
xlabel(<span class="string">'Distance'</span>)
ylabel(<span class="string">'Phase, deg.'</span>)
axis([0, 20, -500, 200])
title(<span class="string">'Wrapped data'</span>)
<span class="comment">% This ambuiguity can be corrected by finding jumps &gt;180 and correcting</span>
<span class="comment">% them by 360 in the opposite direction</span>

<span class="comment">% Additionaly, the laser has another 180 ambuiguity that occurs randomly</span>
idx = randi(numel(x),1,randi(4)+2);
y(idx) = y(idx)+90;
y(y&lt;-360) = y(y&lt;-360)+360;

subplot(4,1,3)
plot(x,y)
xlabel(<span class="string">'Distance'</span>)
ylabel(<span class="string">'Phase, deg.'</span>)
axis([0, 20, -500, 200])
title(<span class="string">'Wrapped data + 90^o ambuiguity'</span>)

<span class="comment">% And on top of this, there's expermimental noise</span>
y = y+randn(1,numel(x))*20;
y(idx) = y(idx)+90;
y(y&lt;-360) = y(y&lt;-360)+360;

subplot(4,1,4)
plot(x,y)
xlabel(<span class="string">'Distance'</span>)
ylabel(<span class="string">'Phase, deg.'</span>)
axis([0, 20, -500, 200])
title(<span class="string">'Wrapped data + 90^o ambuiguity + noise'</span>)
</pre><img vspace="5" hspace="5" src="stochasticUnwrap3_01.png" alt=""> <h2 id="3">Real data</h2><p>Example of some real data</p><pre class="codeinput">pd = [20.5266666666667, <span class="keyword">...</span>
    160.786666666667, <span class="keyword">...</span>
    35.4016666666667, <span class="keyword">...</span>
    23.3403333333333, <span class="keyword">...</span>
    15.5520000000000, <span class="keyword">...</span>
    122.297333333333, <span class="keyword">...</span>
    -4.40333333333334, <span class="keyword">...</span>
    153.523333333333, <span class="keyword">...</span>
    27.2330000000000, <span class="keyword">...</span>
    38.8366666666667, <span class="keyword">...</span>
    42.6206666666667, <span class="keyword">...</span>
    182.884900000000, <span class="keyword">...</span>
    170.231000000000, <span class="keyword">...</span>
    161.493333333333, <span class="keyword">...</span>
    129.882666666667, <span class="keyword">...</span>
    100.144333333333, <span class="keyword">...</span>
    84.9866666666667, <span class="keyword">...</span>
    14.9004333333333];

figure
plot(x, pd)
axis([0, 20, -500, 200])
xlabel(<span class="string">'Distance'</span>)
ylabel(<span class="string">'Phase, deg.'</span>)
</pre><img vspace="5" hspace="5" src="stochasticUnwrap3_02.png" alt=""> <h2 id="4">The problem</h2><p>Find the real phase trajectory of pd (or restore the known, original phase trajecotry of fake data in y)</p><pre class="codeinput">figure; hold <span class="string">on</span>
plot(x, y)
plot(x, pd)
axis([0, 20, -500, 200])
xlabel(<span class="string">'Distance'</span>)
ylabel(<span class="string">'Phase, deg.'</span>)
legend(<span class="string">'y'</span>, <span class="string">'pd'</span>)
</pre><img vspace="5" hspace="5" src="stochasticUnwrap3_03.png" alt=""> <h2 id="5">Step 1: Single, simple unwraps</h2><p>Unwrap 360 and 180 degreee ambuiguties in seperate steps params.upThresh and params.downThresh are the up and down thresholds for correction (the difference between point n and n-1:). downThresh is triggered if the next point goes down buy more than this value, and the next point will be corrected UP by downCor. Because phase is rolling off, the downThresh should be greater than the upThresh. Eg. If phase rolls off -20 deg between each point, upThresh should be 180+-20 = 160 and downThresh should be -180+-20 = -200 Unwrap 3 also normalises the first few points to roughly 0</p><pre class="codeinput">rhoPhase = -20;

params.plotOn = 1;

<span class="comment">% Unwrap large phase jumps (360o jumps)</span>
params.upThresh = 180+rhoPhase;
params.downThresh = -180+rhoPhase;
params.upCor = -360;
params.downCor = 360;

yU = unwrap3(y, params);
pdU = unwrap3(pd, params);

<span class="comment">% Unwrap laser ambuguity (180o jumps)</span>
params.upThresh = 90+rhoPhase;
params.downThresh = -90+rhoPhase;
params.upCor = -180;
params.downCor = 180;

yU2 = unwrap3(yU, params);
pdU2 = unwrap3(pdU, params);

<span class="comment">% This works well for y (with low noise)</span>
figure; hold <span class="string">on</span>
subplot(2,1,1)
plot(y)
plot(yU)
plot(yU2)
legend({<span class="string">'Wrapped'</span>, <span class="string">'Unwrapped pass 1'</span>, <span class="string">'Unwrapped pass 2'</span>})
title(<span class="string">'y'</span>)
axis([0, 20, -500, 200])
subplot(2,1,2)
plot(2:numel(x), diff(yU2)/(max(yU2)-min(yU2))*100, <span class="string">'r'</span>)
title(<span class="string">'Difference between points, scaled by range'</span>)
ylabel(<span class="string">'Diff'</span>)
xlabel(<span class="string">'Distance'</span>)
axis([0, 20, -100, 100])

<span class="comment">% But for pd there are a few points that perhaps should be been corrected,</span>
<span class="comment">% but didn't hit threshold because of noise</span>
figure
subplot(2,1,1); hold <span class="string">on</span>
plot(pd)
plot(pdU)
plot(pdU2)
legend({<span class="string">'Wrapped'</span>, <span class="string">'Unwrapped pass 1'</span>, <span class="string">'Unwrapped pass 2'</span>})
title(<span class="string">'pd'</span>)
axis([0, 20, -500, 200])
subplot(2,1,2)
plot(2:numel(x), diff(pdU2)/(max(pdU2)-min(pdU2))*100, <span class="string">'r'</span>)
ylabel(<span class="string">'Diff'</span>)
xlabel(<span class="string">'Distance'</span>)
axis([0, 20, -100, 100])
</pre><pre class="codeoutput">Warning: Ignoring extra legend entries. 
</pre><img vspace="5" hspace="5" src="stochasticUnwrap3_04.png" alt=""> <img vspace="5" hspace="5" src="stochasticUnwrap3_05.png" alt=""> <img vspace="5" hspace="5" src="stochasticUnwrap3_06.png" alt=""> <img vspace="5" hspace="5" src="stochasticUnwrap3_07.png" alt=""> <img vspace="5" hspace="5" src="stochasticUnwrap3_08.png" alt=""> <img vspace="5" hspace="5" src="stochasticUnwrap3_09.png" alt=""> <h2 id="6">Experimental noise</h2><p>At this point if the unwrap is known to be correct, we can calucalte the experimental noise at each point. For y, even if we pretend we don't know the rate of roll off, we can caluclate the noise at each point as each point is</p><pre class="codeinput">disp(diff(pdU2)/(max(pdU2)-min(pdU2))*100 - 0)
<span class="comment">% However, for pd, we don't know if we've missed unwrap steps, or where</span>
<span class="comment">% they would be</span>
<span class="comment">% One possible approach to dealing with this is to simulate the noise at</span>
<span class="comment">% each point and see what the resulting unwraps look like. We can assume,</span>
<span class="comment">% that with enough simulations, one will coincidenally exactly cancel the</span>
<span class="comment">% experimental noise at each point - but how to know which one?</span>
</pre><pre class="codeoutput">  Columns 1 through 7
  -19.1315   26.2926   -5.8065   -3.7494  -35.2660   25.6592  -10.6265
  Columns 8 through 14
   25.8567    5.5862    1.8217  -19.1295   -6.0918   -4.2065  -15.2179
  Columns 15 through 17
  -14.3165   -7.2972  -33.7407
</pre><h2 id="7">Add noise (before unwrapping) and unwrap again</h2><p>Run for both pd and y - if this works we should be able to recover y and compare it to the known original</p><pre class="codeinput"><span class="comment">% Assumed real phase roll off</span>
roPhase = 20;

params.plotOn = 0;
its = 1000;

<span class="comment">% Noise parameters</span>
mu = 0;
sig = 13; <span class="comment">% ?</span>

<span class="comment">% Output matrix (it x pos)</span>
nPos = numel(x);
pdUWs = NaN(its, nPos);
yUWs = NaN(its, nPos);

<span class="keyword">for</span> it = 1:its
    noiseVec = randn(1, nPos)*sig + mu;

    pdN = pd + noiseVec;
    yN = y + noiseVec;

    <span class="comment">% Unwrap large phase jumps</span>
    params.upThresh = 90+roPhase;
    params.downThresh = -90+roPhase;
    params.upCor = -360;
    params.downCor = 360;
    pdNU = unwrap3(pdN, params);
    yNU = unwrap3(yN, params);

    <span class="comment">% Unwrap laser ambuguity</span>
    params.upThresh = 75;
    params.downThresh = -75;
    params.upCor = -180;
    params.downCor = 180;
    pdUWs(it,:) = unwrap3(pdNU, params);
    yUWs(it,:) = unwrap3(yNU, params);
<span class="keyword">end</span>

h(1) = figure;
subplot(1,4,1:3); hold <span class="string">on</span>
plot(yUWs')
xlabel(<span class="string">'Distance'</span>)
ylabel(<span class="string">'Phae, deg.'</span>)
title(<span class="string">'y'</span>)
subplot(1,4,4)
histogram(yUWs(:,end),100)
a = gca;
a.View = [90 -90];
a.XTickLabel = [];
ylabel(<span class="string">'Count'</span>)

h(2) = figure;
subplot(1,4,1:3); hold <span class="string">on</span>
plot(pdUWs')
xlabel(<span class="string">'Distance'</span>)
ylabel(<span class="string">'Phae, deg.'</span>)
title(<span class="string">'pd'</span>)
subplot(1,4,4)
histogram(pdUWs(:,end),100)
a = gca;
a.View = [90 -90];
a.XTickLabel = [];
ylabel(<span class="string">'Count'</span>)
</pre><img vspace="5" hspace="5" src="stochasticUnwrap3_10.png" alt=""> <img vspace="5" hspace="5" src="stochasticUnwrap3_11.png" alt=""> <h2 id="8">Select best path</h2><p>So there a quite a few possible phase trajectories, not normally distributed overall but perhaps normally distributed within possible groups But which is the correct trajectory?</p><pre class="codeinput"><span class="comment">% Minimise sum of jumps? - Smoothest path</span>
<span class="comment">% Get differences between each position</span>
dfs = diff(pdUWs');
<span class="comment">% Sum ABS</span>
sdfs = sum(abs(dfs));
<span class="comment">% Get path with smallest difference</span>
[~, mIdx] = min(sdfs);
pdMin = pdUWs(mIdx,:);
<span class="comment">% Same for y</span>
dfs = diff(yUWs');
sdfs = sum(abs(dfs));
[~, mIdx] = min(sdfs);
yMin = yUWs(mIdx,:);

<span class="comment">% Mean best path</span>
pdMean = mean(pdUWs);
yMean = mean(yUWs);

<span class="comment">% Mode best path</span>
pdMode = mode(round(pdUWs,0));
yMode = mode(round(yUWs,0));

figure(h(1))
axes(h(1).Children(2))
sp(1) = plot(yMin, <span class="string">'LineWidth'</span>, 3, <span class="string">'color'</span>, <span class="string">'k'</span>);
sp(2) = plot(yMean, <span class="string">'LineWidth'</span>, 3, <span class="string">'color'</span>, <span class="string">'k'</span>, <span class="string">'LineStyle'</span>, <span class="string">'--'</span>);
sp(3) = plot(yMode, <span class="string">'LineWidth'</span>, 3, <span class="string">'color'</span>, <span class="string">'k'</span>, <span class="string">'LineStyle'</span>, <span class="string">'-.'</span>);
legend(sp, {<span class="string">'Smoothest'</span>, <span class="string">'Mean'</span>, <span class="string">'Mode'</span>})

figure(h(2))
axes(h(2).Children(2))
sp(1) = plot(pdMin, <span class="string">'LineWidth'</span>, 3, <span class="string">'color'</span>, <span class="string">'k'</span>);
sp(2) = plot(pdMean, <span class="string">'LineWidth'</span>, 3, <span class="string">'color'</span>, <span class="string">'k'</span>, <span class="string">'LineStyle'</span>, <span class="string">'--'</span>);
sp(3) = plot(pdMode, <span class="string">'LineWidth'</span>, 3, <span class="string">'color'</span>, <span class="string">'k'</span>, <span class="string">'LineStyle'</span>, <span class="string">'-.'</span>);
legend(sp, {<span class="string">'Smoothest'</span>, <span class="string">'Mean'</span>, <span class="string">'Mode'</span>})

<span class="comment">% For y roughly the correct trajectory has been sselected by the smoothest</span>
<span class="comment">% and mean path selections - but there is certinaly still noise present.</span>
<span class="comment">% For pd, ?</span>
</pre><img vspace="5" hspace="5" src="stochasticUnwrap3_12.png" alt=""> <img vspace="5" hspace="5" src="stochasticUnwrap3_13.png" alt=""> <p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2016b</a><br></p></div><!--
##### SOURCE BEGIN #####
% Examples using unwrap3
% Allows different values for correcting up and down jumps
close all

%% The data
% What the data looks like

% This is what we're assuming clean data roughly looks like
% (oversimiplified a bit)
% x is distance
% y is phase in degrees

x = 1:18;
y = linspace(0, -480, numel(x));

figure
subplot(4,1,1)
plot(x,y)
xlabel('Distance')
ylabel('Phase, deg.')
axis([0, 20, -600, 200])
title('Clean data')

% Raw data can only be recorded between 0-360 degrees, so clean data in
% it's raw form would look like this.
y(y<-360) = y(y<-360)+360;

subplot(4,1,2)
plot(x,y)
xlabel('Distance')
ylabel('Phase, deg.')
axis([0, 20, -500, 200])
title('Wrapped data')
% This ambuiguity can be corrected by finding jumps >180 and correcting
% them by 360 in the opposite direction

% Additionaly, the laser has another 180 ambuiguity that occurs randomly
idx = randi(numel(x),1,randi(4)+2);
y(idx) = y(idx)+90;
y(y<-360) = y(y<-360)+360;

subplot(4,1,3)
plot(x,y)
xlabel('Distance')
ylabel('Phase, deg.')
axis([0, 20, -500, 200])
title('Wrapped data + 90^o ambuiguity')

% And on top of this, there's expermimental noise
y = y+randn(1,numel(x))*20;
y(idx) = y(idx)+90;
y(y<-360) = y(y<-360)+360;

subplot(4,1,4)
plot(x,y)
xlabel('Distance')
ylabel('Phase, deg.')
axis([0, 20, -500, 200])
title('Wrapped data + 90^o ambuiguity + noise')

%% Real data
% Example of some real data

pd = [20.5266666666667, ...
    160.786666666667, ...
    35.4016666666667, ...
    23.3403333333333, ...
    15.5520000000000, ...
    122.297333333333, ...
    -4.40333333333334, ...
    153.523333333333, ...
    27.2330000000000, ...
    38.8366666666667, ...
    42.6206666666667, ...
    182.884900000000, ...
    170.231000000000, ...
    161.493333333333, ...
    129.882666666667, ...
    100.144333333333, ...
    84.9866666666667, ...
    14.9004333333333];

figure
plot(x, pd)
axis([0, 20, -500, 200])
xlabel('Distance')
ylabel('Phase, deg.')

%% The problem
% Find the real phase trajectory of pd (or restore the known, original 
% phase trajecotry of fake data in y)
figure; hold on
plot(x, y)
plot(x, pd)
axis([0, 20, -500, 200])
xlabel('Distance')
ylabel('Phase, deg.')
legend('y', 'pd')


%% Step 1: Single, simple unwraps
% Unwrap 360 and 180 degreee ambuiguties in seperate steps
% params.upThresh and params.downThresh are the up and down thresholds for
% correction (the difference between point n and n-1:). downThresh is
% triggered if the next point goes down buy more than this value, and the
% next point will be corrected UP by downCor.
% Because phase is rolling off, the downThresh should be greater than the
% upThresh. Eg. If phase rolls off -20 deg between each point, upThresh
% should be 180+-20 = 160 and downThresh should be -180+-20 = -200
% Unwrap 3 also normalises the first few points to roughly 0
rhoPhase = -20;

params.plotOn = 1;

% Unwrap large phase jumps (360o jumps)
params.upThresh = 180+rhoPhase;
params.downThresh = -180+rhoPhase;
params.upCor = -360;
params.downCor = 360;

yU = unwrap3(y, params);
pdU = unwrap3(pd, params);

% Unwrap laser ambuguity (180o jumps)
params.upThresh = 90+rhoPhase;
params.downThresh = -90+rhoPhase;
params.upCor = -180;
params.downCor = 180;

yU2 = unwrap3(yU, params);
pdU2 = unwrap3(pdU, params);

% This works well for y (with low noise)
figure; hold on
subplot(2,1,1)
plot(y)
plot(yU)
plot(yU2)
legend({'Wrapped', 'Unwrapped pass 1', 'Unwrapped pass 2'})
title('y')
axis([0, 20, -500, 200])
subplot(2,1,2)
plot(2:numel(x), diff(yU2)/(max(yU2)-min(yU2))*100, 'r')
title('Difference between points, scaled by range')
ylabel('Diff')
xlabel('Distance')
axis([0, 20, -100, 100])

% But for pd there are a few points that perhaps should be been corrected,
% but didn't hit threshold because of noise
figure
subplot(2,1,1); hold on
plot(pd)
plot(pdU)
plot(pdU2)
legend({'Wrapped', 'Unwrapped pass 1', 'Unwrapped pass 2'})
title('pd')
axis([0, 20, -500, 200])
subplot(2,1,2)
plot(2:numel(x), diff(pdU2)/(max(pdU2)-min(pdU2))*100, 'r')
ylabel('Diff')
xlabel('Distance')
axis([0, 20, -100, 100])


%% Experimental noise
% At this point if the unwrap is known to be correct, we can calucalte the
% experimental noise at each point. For y, even if we pretend we don't know 
% the rate of roll off, we can caluclate the noise at each point as
% each point is
disp(diff(pdU2)/(max(pdU2)-min(pdU2))*100 - 0)
% However, for pd, we don't know if we've missed unwrap steps, or where
% they would be
% One possible approach to dealing with this is to simulate the noise at
% each point and see what the resulting unwraps look like. We can assume,
% that with enough simulations, one will coincidenally exactly cancel the
% experimental noise at each point - but how to know which one?


%% Add noise (before unwrapping) and unwrap again
% Run for both pd and y - if this works we should be able to recover y and
% compare it to the known original

% Assumed real phase roll off
roPhase = 20;

params.plotOn = 0;   
its = 1000;

% Noise parameters
mu = 0;
sig = 13; % ?

% Output matrix (it x pos)
nPos = numel(x);
pdUWs = NaN(its, nPos);
yUWs = NaN(its, nPos);

for it = 1:its
    noiseVec = randn(1, nPos)*sig + mu;
    
    pdN = pd + noiseVec; 
    yN = y + noiseVec;
    
    % Unwrap large phase jumps
    params.upThresh = 90+roPhase;
    params.downThresh = -90+roPhase;
    params.upCor = -360;
    params.downCor = 360;
    pdNU = unwrap3(pdN, params);
    yNU = unwrap3(yN, params);
    
    % Unwrap laser ambuguity
    params.upThresh = 75;
    params.downThresh = -75;
    params.upCor = -180;
    params.downCor = 180;
    pdUWs(it,:) = unwrap3(pdNU, params);
    yUWs(it,:) = unwrap3(yNU, params);
end

h(1) = figure;
subplot(1,4,1:3); hold on
plot(yUWs')
xlabel('Distance')
ylabel('Phae, deg.')
title('y')
subplot(1,4,4)
histogram(yUWs(:,end),100)
a = gca;
a.View = [90 -90];
a.XTickLabel = [];
ylabel('Count')

h(2) = figure;
subplot(1,4,1:3); hold on
plot(pdUWs')
xlabel('Distance')
ylabel('Phae, deg.')
title('pd')
subplot(1,4,4)
histogram(pdUWs(:,end),100)
a = gca;
a.View = [90 -90];
a.XTickLabel = [];
ylabel('Count')


%% Select best path
% So there a quite a few possible phase trajectories, not normally
% distributed overall but perhaps normally distributed within possible 
% groups
% But which is the correct trajectory?

% Minimise sum of jumps? - Smoothest path
% Get differences between each position
dfs = diff(pdUWs');
% Sum ABS
sdfs = sum(abs(dfs));
% Get path with smallest difference
[~, mIdx] = min(sdfs);
pdMin = pdUWs(mIdx,:);
% Same for y
dfs = diff(yUWs');
sdfs = sum(abs(dfs));
[~, mIdx] = min(sdfs);
yMin = yUWs(mIdx,:);

% Mean best path
pdMean = mean(pdUWs);
yMean = mean(yUWs);

% Mode best path
pdMode = mode(round(pdUWs,0));
yMode = mode(round(yUWs,0));

figure(h(1))
axes(h(1).Children(2))
sp(1) = plot(yMin, 'LineWidth', 3, 'color', 'k');
sp(2) = plot(yMean, 'LineWidth', 3, 'color', 'k', 'LineStyle', 'REPLACE_WITH_DASH_DASH');
sp(3) = plot(yMode, 'LineWidth', 3, 'color', 'k', 'LineStyle', '-.');
legend(sp, {'Smoothest', 'Mean', 'Mode'})

figure(h(2))
axes(h(2).Children(2))
sp(1) = plot(pdMin, 'LineWidth', 3, 'color', 'k');
sp(2) = plot(pdMean, 'LineWidth', 3, 'color', 'k', 'LineStyle', 'REPLACE_WITH_DASH_DASH');
sp(3) = plot(pdMode, 'LineWidth', 3, 'color', 'k', 'LineStyle', '-.');
legend(sp, {'Smoothest', 'Mean', 'Mode'})

% For y roughly the correct trajectory has been sselected by the smoothest
% and mean path selections - but there is certinaly still noise present.
% For pd, ?
##### SOURCE END #####
--></body></html>